import numpy as np
import math
import sys
import os
import glob
import pandas as pd
import seaborn as sb
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import FormatStrFormatter
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker 
from datetime import datetime
from matplotlib.colors import ListedColormap
from mpl_toolkits import mplot3d
start_time = datetime.now()

## ------------------------------------------------------------------------------
##
## Created by : Mary Clay PhD
## e-mail: mary.clay@stjude.org
## St Jude Children's Research Hospital 
## Department of Structural Biology Memphis, TN 
##
## Last update: July 29, 2021
##
##
## ------------------------------------------------------------------------------
## ------------------------------------------------------------------------------
### Matplot lib settings
linewidths = 1
mpl.rcParams['pdf.fonttype'] = 42
mpl.rcParams['font.sans-serif'] = 'arial'
mpl.rcParams['font.size'] = 8
mpl.rcParams['axes.linewidth'] = linewidths
mpl.rcParams['xtick.direction'] = mpl.rcParams['ytick.direction']='out'
mpl.rcParams['xtick.labelsize'] = mpl.rcParams['ytick.labelsize']=8
mpl.rcParams['xtick.major.size'] = mpl.rcParams['ytick.major.size'] = 4
mpl.rcParams['xtick.major.width'] = mpl.rcParams['ytick.major.width']=linewidths
mpl.rcParams['xtick.minor.size'] = 2
mpl.rcParams['xtick.minor.width'] = linewidths
mpl.rcParams['axes.spines.right'] = False
mpl.rcParams['axes.spines.top'] = False
mpl.rcParams['legend.fontsize'] = 8
mpl.rcParams['legend.loc'] = 'best'
mpl.rcParams['legend.borderpad'] = 0.01
mpl.rcParams['legend.frameon'] = False
mpl.rcParams['legend.handlelength'] = 0
mpl.rcParams['legend.scatterpoints'] = 1
mpl.rcParams['xtick.major.bottom'] = mpl.rcParams['ytick.major.left'] = True
mpl.rcParams['xtick.major.top'] = mpl.rcParams['ytick.major.right'] = True
mpl.rcParams['mathtext.fontset'] = 'cm'
mpl.rcParams['mathtext.sf'] = 'sans\\-serif'
plt.rcParams['mathtext.default'] = 'regular'
mpl.rcParams['xtick.major.pad']=mpl.rcParams['ytick.major.pad']= 2
mpl.rcParams['axes.labelpad'] = 3
## ------------------------------------------------------------------------------
## ------------------------------------------------------------------------------
### Dictonaries for translating three letter code to single letter codes, and determin the number of protons in sample
AAA_dict = {"ALA": "A", "ARG": "R", "ASN": "N", "ASP": "D", "CYS": "C", "GLU": "E", "GLN": "Q", "GLY": "G", "HIS": "H", "ILE": "I", "LEU": "L", "LYS": "K", "MET": "M", "PHE": "F", "PRO": "P", "SER": "S", "THR": "T", "TRP": "W", "TYR": "Y", "VAL": 'V', "MSE":'M', "PTR":'Y', "TPO":"T", "SEP":'S'}
A_dict = {'I':'Isoleucine', 'L':'Leucine','V':'Valine','A':'Alanine', 'T':'Threonine','M':'Methionine'}
## AA_dic = A:[MW, ExH, Methyl_H, Methyl_C, NonExH , Total_H, N, C]
AA_dic = {"A":[71.079 , 1, 3, 1, 4,  5,  1, 3],"C":[103.139, 1, 0, 0, 4,  5,  1, 3],"D":[115.089, 2, 0, 0, 3,  5,  1, 4],"E":[129.116, 2, 0, 0, 5,  7,  1, 5],"F":[147.177, 1, 0, 0, 8,  9,  1, 9],"G":[57.052 , 1, 0, 0, 2,  3,  1, 2],"H":[137.141, 3, 0, 0, 5,  8,  3, 6],
"I":[113.16 , 1, 3, 1, 10, 11, 1, 6],"K":[128.174, 4, 0, 0, 9,  13, 2, 6], "L":[113.16 , 1, 6, 2, 10, 11, 1, 6],"M":[131.193, 1, 3, 1, 8,  9,  1, 6], "N":[114.104, 3, 0, 0, 3,  6,  2, 3], "P":[97.117 , 0, 0, 0, 7,  7,  1, 5],
"Q":[128.131, 3, 0, 0, 5,  8,  2, 5],"R":[156.188, 6, 0, 0, 7,  13, 4, 6], "S":[87.078 , 2, 0, 0, 3,  5,  1, 3], "T":[101.104, 2, 3, 1, 5,  7,  1, 4], "V":[99.133 , 1, 6, 2, 8,  9,  1, 5],"W":[186.213, 2, 0, 0, 8,  10, 2, 11], 
"Y":[163.176, 2, 0, 0, 7,  9,  1, 9]}
## ------------------------------------------------------------------------------


## ------------------------------------------------------------------------------
## Lets get started make a directory to store the csv files generated by this script
## read in the PDB file used it to generate the sequence. 

if len(sys.argv)==1:
	print '''
Usage: 
	MAGIC-Net [output name] [pdb] 

	ex) MAGIC-Net FGFR3 4K33.pdb
'''
	exit()

CurDir = os.getcwd()
if not os.path.exists(CurDir + '/'+  sys.argv[1]+'/CSV/'):
	os.makedirs(CurDir + '/'+  sys.argv[1]+'/CSV/')

if not os.path.exists(CurDir + '/'+  sys.argv[1]+'/'):
	os.makedirs(CurDir + '/'+  sys.argv[1]+'/')
outname = CurDir + '/'+ sys.argv[1]+'/'+ sys.argv[1]
pdb_name=CurDir + '/'+ sys.argv[2]

csvoutname = CurDir + '/'+sys.argv[1]+'/CSV/' + sys.argv[1]

Labelings=['ILVMAT', 'ILVMA','ILVM', 'ILVA','ILV']
LV_Labeling = ['sym','mono','stero']
lowCuts=[6,7,10]

outcolumns = ['Expected']
for val in ['A_NOE/me', 'A_LN/me','A_ULN/me',]:
	for LowCut in lowCuts:
		outcolumns.append(str(LowCut) + val)
for LowCut in lowCuts:
	for val in ['A_NOE', 'A_LN', 'A_ULN','A_iso']:
		outcolumns.append(str(LowCut) + val)
# out_table = pd.DataFrame(columns=[outcolumns])

for method in LV_Labeling:
	exec(method + "_summary = pd.DataFrame(columns=[outcolumns])")
	for lowCut in lowCuts: 
		exec(method + "_"+ str(lowCut) + "_PDB_summary = pd.DataFrame(columns = ['Resid','type'])")


Labeled = {'I':['CD1'],'M':['CE'],'A':['CB'], 'T':['CG2'],'L':['CD1','CD2'], 'V':['CG1','CG2']}
Allowd = {'sym':{'I':['CD1'],'M':['CE'],'A':['CB'], 'T':['CG2'],'L':['CD1','CD2'], 'V':['CG1','CG2']}, 'mono':{'I':['CD1'],'M':['CE'],'A':['CB'], 'T':['CG2'],'L':['CD1','CD2'], 'V':['CG1','CG2']},
'stero':{'I':['CD1'],'M':['CE'],'A':['CB'], 'T':['CG2'],'L':['CD1'], 'V':['CG1']}}

SEQ = []
All_PDB_entries = {} # (L220-CD1, type, atom, x, y, z)
PDB_entries = []
LV_entries = []
####---------------------------------------------------------------------------
## Find the line in the PDB file for methyl carbon atoms and generate the Model (Mmatrix)
## Generates a dictionary All_PDB_entries[methyl] = [(methyl, type, atom, x, y, z)]
###---------------------------------------------------------------------------

for line in open(pdb_name):
	if line[0:4] == "ATOM" or line[0:4] == 'HETA':
		if line[17:20].strip() in AAA_dict.keys():
			if line[12:16].strip() == 'CA':
				SEQ.append(AAA_dict[line[17:20].strip()])
			if AAA_dict[line[17:20].strip()] in Labeled.keys() and line[12:16].strip() in Labeled[AAA_dict[line[17:20].strip()]]:
				methyl = AAA_dict[line[17:20].strip()] + line[22:26].strip() + '-' + line[12:16].strip()
				All_PDB_entries[methyl] =[methyl,AAA_dict[line[17:20].strip()], line[12:16].strip(), float(line[30:38]), float(line[38:46]), float(line[46:54])]
				PDB_entries.append(methyl)
				if methyl[0] in ['L','V']: LV_entries.append(methyl)

protonsDF = pd.DataFrame(index=LV_Labeling)

for method in LV_Labeling:
	protonsDF.loc[method,'nRes'] = len(SEQ)
	for aa in ['I','L','V','M','A','T']:
		if aa in ['L','V'] and method == 'sym':
			protonsDF.loc[method,aa] = SEQ.count(aa)*2.0
		else:
			protonsDF.loc[method,aa] = SEQ.count(aa)
	protonsDF.loc[method,'ExH'] = 0
	protonsDF.loc[method,'NonExH'] = 0
	protonsDF.loc[method,'TotalH'] = 0
	for res in SEQ:
		protonsDF.loc[method,'ExH'] = protonsDF.loc[method,'ExH'] + AA_dic[res][1]
		protonsDF.loc[method,'NonExH'] = protonsDF.loc[method,'NonExH'] + AA_dic[res][4]
		protonsDF.loc[method,'TotalH'] = protonsDF.loc[method,'TotalH'] +  AA_dic[res][5]
	for me in ['I','L','V','M','A','T']:
		protonsDF.loc[method, me+ 'f_AllH'] = ((protonsDF.loc[method, me] *3.0)/protonsDF.loc[method,'TotalH'])*100
		protonsDF.loc[method, me+ 'f_NoExH'] = ((protonsDF.loc[method, me] *3.0)/protonsDF.loc[method,'NonExH'])*100

protonsDF.fillna(0.0)
protonsDF.to_csv(outname + '_'+'Protonation.csv')

tmethyls,pmethyls= [],[],
pprotons,pprotonsmono, = [float(protonsDF.loc['sym','ExH']/protonsDF.loc['sym','TotalH'])*100.0],[0.0]

metot = 0
for me in 'ILVMAT':
	metot = metot + float(protonsDF.loc['sym', me ])
	tmethyls.append(float(protonsDF.loc['sym', me ]))
	if me in ['I','M','A','T']:
		pprotons.append(float(protonsDF.loc['sym',me]*3/protonsDF.loc['sym','NonExH'])*100.0)
		pprotonsmono.append(0.0)
	if me in ['L','V']:
		pprotons.append(float(protonsDF.loc['sym',me]*6/protonsDF.loc['sym','NonExH'])*100.0)
		pprotonsmono.append(float(protonsDF.loc['sym',me]*3/protonsDF.loc['sym','NonExH'])*100.0)
for i in range(len(tmethyls)):
	pmethyls.append((float(tmethyls[i])/metot)*100)

for method in LV_Labeling:
	print method
	pdf1 = PdfPages(outname + '_globalnetworks_' + method + '.pdf')
	pdf2 = PdfPages(outname + '_subnetworsks_'+ method + '.pdf')
	pdf3 = PdfPages(outname + '_local_networks_'+ method + '.pdf')
	PDB_Summary = eval(method + "_"+ str(lowCut) + "_PDB_summary")
	method_atoms = []
	allowed_atoms = Allowd[method]
	for entry in PDB_entries:
		if entry[0] in ['I','L','V','M','A','T']:
			if entry.split('-')[-1] in allowed_atoms[entry[0]]:
				PDB_Summary.loc[entry, 'type'] = entry[0]
				PDB_Summary.loc[entry, 'Resid'] = entry.split('-')[0]
				method_atoms.append(entry)
	for lowCut in lowCuts:
		####---------------------------------------------------------------------------
		## Generate the connectivity matrix from the PDB retaining only C-C distance <= cutoff
		####---------------------------------------------------------------------------
		FMmatrix = pd.DataFrame(index = method_atoms, columns = method_atoms)
		for atom1 in method_atoms: 
			(methyl1, type1, atom1, x1, y1, z1) = All_PDB_entries[atom1]
			for atom2 in method_atoms: 
				(methyl2, type2, atom2, x2, y2, z2) = All_PDB_entries[atom2]
				if methyl1.split('-')[0] != methyl2.split('-')[0]:
					d = round(np.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2),1)
					if d != 0 and d <= lowCut: 
						FMmatrix.loc[methyl1, methyl2] = round((d),2)
		## Set the diagonal of the FMmatrix = to 1 so that each methyl is explicitly present in its local network so it will be counted in the LN id
		for methyl in method_atoms:
			FMmatrix.loc[methyl, methyl] = 1.0
		## If using conventional LV labeling, add in the geminal pair information, but set the distance at 3.51A so it shows up on the network maps. 
		if method == 'sym':
			for methyl1 in LV_entries: 
				for methyl2 in LV_entries: 
					if methyl1 != methyl2 and methyl1.split('-')[0] == methyl2.split('-')[0]:
						FMmatrix.loc[methyl1, methyl2] = 3.51
		####---------------------------------------------------------------------------
		## Generate a list of the labeled methyl for each labeling scheme, extract the correct entries from FMmatrix 
		####---------------------------------------------------------------------------
		for labeling in Labelings:
			Ilist, Mlist, Llist, Vlist, Tlist, Alist = [],[],[],[],[],[]
			Allowed_atoms = Allowd[method]
			PDB_atoms = []
			for entry in PDB_entries:
				if entry[0] in labeling:
					if entry.split('-')[-1] in Allowed_atoms[entry[0]]:
						outlist = eval(entry[0] + 'list')
						outlist.append(entry)
						PDB_atoms.append(entry)
			plotlist = []
			for me in ['I','M','A','T','V','L']:
				if me in labeling:
					plotlist.extend(eval(me+'list'))
			## Make list of valuse for drawing grid on global network and subnetwork plots 
			plotgrid = {}
			tot = 0
			for me in ['I','M','A','T','V','L']:
				if me in labeling:
					tot = tot + (len(eval(me+'list')))
					plotgrid[me] = tot
			Mmatrix = FMmatrix.reindex(PDB_atoms, columns=PDB_atoms)

			####---------------------------------------------------------------------------
			## Symmetrizing the Leu/Val Geminal Pairs if using sym method
			## Get the donor list for each methyl, and check to make sure if a Leu or Val
			## is in the donor list that both of the geminal carbons are present.
			## If not then calculate the distance and add the (methyl, donor) and (donor, methyl)
			## entries into the FMmatrix. 
			if method == 'sym':
				for methyl in PDB_atoms:
					(methyl, type1, atom1, x1, y1, z1) = All_PDB_entries[methyl]
					donors = Mmatrix.dropna(axis=0,subset=[methyl], how = 'any').index.tolist()
					for donor in donors:
						if donor[0] == 'L':
							if donor.split('-')[0] + '-CD1' not in donors:
								(methyl2, type2, atom2, x2, y2, z2) = All_PDB_entries[donor.split('-')[0] + '-CD1']
								d = round(np.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2),2)
								Mmatrix.loc[methyl, methyl2] = d
								Mmatrix.loc[methyl2, methyl] = d
								donors.append(methyl2)
							if donor.split('-')[0] + '-CD2' not in donors:
								(methyl2, type2, atom2, x2, y2, z2) = All_PDB_entries[donor.split('-')[0] + '-CD2']
								d = round(np.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2),2)
								Mmatrix.loc[methyl, methyl2] = d
								Mmatrix.loc[methyl2, methyl] = d
								donors.append(methyl2)
						if donor[0] == 'V':
							if donor.split('-')[0] + '-CG1' not in donors:
								(methyl2, type2, atom2, x2, y2, z2) = All_PDB_entries[donor.split('-')[0] + '-CG1']
								d = round(np.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2),2)
								Mmatrix.loc[methyl, methyl2] = round((d),2)
								Mmatrix.loc[methyl2, methyl] = round((d),2)
								donors.append(methyl2)
							if donor.split('-')[0] + '-CG2' not in donors:
								(methyl2, type2, atom2, x2, y2, z2) = All_PDB_entries[donor.split('-')[0] + '-CG2']
								d = round(np.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2),2)
								Mmatrix.loc[methyl, methyl2] = round((d),2)
								Mmatrix.loc[methyl2, methyl] = round((d),2)
								donors.append(methyl2)

			Mmatrix.dropna(axis=0,thresh=2,inplace=True) # Drop any rows that do not have more than one non 0 value
			Mmatrix.dropna(axis=1,thresh=2,inplace=True) # Drop any columns that do not have more than one non 0 value

			#####-------------------------------------------------------------------------
			## Determine the number of theoretical NOEs for each residue Subtract one to account for diagonal peak
			## Determine the local network id (LN) by counted the number of each type of methyl group with direct connections to the acceptor methyl 
			####--------------------------------------------------------------------------
			for methyl in Mmatrix.index.tolist():

				donors = Mmatrix.dropna(axis=0,subset=[methyl], how = 'any').index.tolist()
				temp = Mmatrix.reindex(donors)[donors]
				used = []
				types  = ''
				count = 0
				donorstr = ''
				for donor in donors:
					donorstr = donorstr + donor + ' '
					if donor.split('-')[0] not in used :
						types = types+ donor[0]
						count+=1
						# used.append(donor.split('-')[0])
				dtc = ''
				for me in labeling:
					if types.count(me) != 0:
						dtc = dtc + me+str(types.count(me))
				if len(donors) >= 1:
					if methyl[0] not in ['L','V']: PDB_Summary.loc[methyl,labeling + '_NOE'] = len(donors) - 1
					if methyl[0] in ['L','V'] and method == 'sym': PDB_Summary.loc[methyl,labeling+'_NOE'] = len(donors) - 2 
					if methyl[0] in ['L','V'] and method != 'sym': PDB_Summary.loc[methyl,labeling+'_NOE'] = len(donors) - 1 
					PDB_Summary.loc[methyl,labeling + '_LN'] = dtc
					PDB_Summary.loc[methyl,labeling + '_Donors'] = donorstr
			for methyl in PDB_Summary.index.tolist():
				if PDB_Summary.loc[methyl,labeling+'_NOE'] == 0.0: PDB_Summary.loc[methyl,labeling+'_LN'] = np.nan
			
			if method == 'sym':
				MSymlist = []
				usedres = []
				for me in PDB_atoms:
					if me.split('-')[0] not in usedres:
						usedres.append(me.split('-')[0])
						MSymlist.append(me)
			else: MSymlist = PDB_atoms
			#####-------------------------------------------------------------------------
			## Count the number of NOEs and unique LN entries for all methyls and 
			## then each methyl type 
			## Calculate the Number of expected methyl and average number of NOE per methyl type
			####--------------------------------------------------------------------------
			cleanPDB = PDB_Summary.reindex(MSymlist).dropna(axis=0, subset=[labeling + '_LN']).copy(deep=True) #keep only entries with local netoworks
			Unique_LN = cleanPDB[labeling + '_LN'].unique().tolist()
			Icount, Lcount, Vcount, Mcount, Acount, Tcount  = 0, 0, 0, 0, 0, 0
			uIcount, uLcount, uVcount, uMcount, uAcount, uTcount  = 0, 0, 0, 0, 0, 0
			oIcount, oLcount, oVcount, oMcount, oAcount, oTcount  = 0, 0, 0, 0, 0, 0
			Fully_unique= []
			for LN in Unique_LN:
				nLN = cleanPDB[labeling + '_LN'].tolist().count(LN)
				if nLN == 1:
					Fully_unique.append(LN)
					if 'I' in LN: uIcount+=1
					if 'M' in LN: uMcount+=1
					if 'V' in LN: uVcount+=1
					if 'L' in LN: uLcount+=1
					if 'A' in LN: uAcount+=1
					if 'T' in LN: uTcount+=1
			if method == 'sym':
				uLcount = uLcount*2
				uVcount = uVcount*2
			for me in PDB_Summary.dropna(axis=0, subset=[labeling + '_LN']).index.tolist():
				LN = PDB_Summary.loc[me,labeling + '_LN']
				if 'I' in LN: Icount+=1
				if 'M' in LN: Mcount+=1
				if 'V' in LN: Vcount+=1
				if 'L' in LN: Lcount+=1
				if 'A' in LN: Acount+=1
				if 'T' in LN: Tcount+=1
			for me in PDB_Summary.dropna(axis=0, subset=[labeling + '_LN']).index.tolist():
				LN = PDB_Summary.loc[me,labeling + '_LN']
				if LN in Fully_unique:
					PDB_Summary.loc[me,labeling + '_ULN'] = 1
			isotot = 0
			Filled_PDB_Summary = PDB_Summary.fillna(0.0)
			for res in Filled_PDB_Summary.index.tolist():
				if Filled_PDB_Summary.loc[res,labeling + '_NOE'] == 0.0:
					for me in labeling:
						if Filled_PDB_Summary.loc[res, 'type'] == me:
							isotot+=1
							if 'I' in me: oIcount+=1
							if 'M' in me: oMcount+=1
							if 'V' in me: oVcount+=1
							if 'L' in me: oLcount+=1
							if 'A' in me: oAcount+=1
							if 'T' in me: oTcount+=1
			out_table = eval(method + "_summary")
			out_table.loc[labeling + '_Total' ,'Expected'] =len(PDB_atoms)
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_NOE'] =PDB_Summary[labeling + '_NOE'].sum()
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_NOE/me'] = np.round(float(PDB_Summary[labeling + '_NOE'].sum())/float(len(PDB_atoms)),2)
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_LN'] =PDB_Summary.dropna(axis=0, subset=[labeling + '_LN']).shape[0]
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_LN/me'] = np.round(PDB_Summary.dropna(axis=0, subset=[labeling + '_LN']).shape[0]/float(len(PDB_atoms)),2)
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_ULN'] = len(Fully_unique)
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_ULN/me'] = np.round(len(Fully_unique)/float(PDB_Summary.shape[0]),2)
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_iso'] = isotot
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_isof'] = np.round(isotot/float(len(PDB_atoms))*100,1)
			ALN = PDB_Summary.dropna(axis=0, subset=[labeling + '_LN']).shape[0] - PDB_Summary.dropna(axis=0, subset=[labeling + '_ULN']).shape[0]
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_Ambiguous'] = np.round(ALN/float(len(PDB_atoms))*100,1)
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_Unambiguous'] = np.round(PDB_Summary.dropna(axis=0, subset=[labeling + '_ULN']).shape[0]/float(len(PDB_atoms))*100,1)
			out_table.loc[labeling + '_Total' ,str(lowCut)+'A_All'] = np.round(PDB_Summary.dropna(axis=0, subset=[labeling + '_LN']).shape[0]/float(len(PDB_atoms))*100,1)
			print labeling + ' ' + method
			print 'Using Cutoff of %d' %lowCut
			print '%d Local Networks' % float(	out_table.loc[labeling + '_Total' ,str(lowCut)+'A_LN'])
			print '%2.1f of Local Networks are Fully Unique' %(len(Fully_unique)/float(cleanPDB.shape[0]))
			for lme in labeling:
				temp = PDB_Summary[PDB_Summary['type'] == lme].copy(deep=True)
				temp2 = temp.dropna(axis=0, subset=[labeling + '_ULN']).copy(deep=True)
				temp3 = temp.dropna(axis=0, subset=[labeling + '_LN']).copy(deep=True)
				if temp.shape[0] != 0:
					out_table.loc[labeling + '_' + lme,'Expected'] = temp.shape[0]
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_NOE'] = temp[labeling + '_NOE'].sum()
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_NOE/me'] = np.round(temp[labeling + '_NOE'].sum()/float(temp.shape[0]),1)
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_LN'] = eval(lme+'count')
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_LN/me'] = np.round(eval(lme+'count')/float(temp.shape[0]),1)
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_ULN'] = eval('u'+ lme+'count')
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_ULN/me'] =np.round(eval('u'+ lme+'count')/float(temp.shape[0]),1)
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_iso'] = eval('o'+ lme+'count')
					if isotot != 0.0:
						out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_isof'] = np.round((eval('o'+ lme+'count')/float(temp.shape[0])*100),1)
					if isotot == 0.0:
						out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_isof'] = 0.0
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_Unambiguous'] = np.round(temp2.shape[0]/float(temp.shape[0])*100,1)
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_Ambiguous'] = np.round((temp3.shape[0]-temp2.shape[0])/float(temp.shape[0])*100,1)
					out_table.loc[labeling + '_' + lme ,str(lowCut)+'A_All'] = np.round(temp3.shape[0]/float(temp.shape[0])*100,1)
				print '%d %s' %(temp.shape[0],lme)
				print '#%s in LN %d' %(lme,eval(lme+'count'))
				print '#%s in unique LN %d' %(lme, eval('u'+ lme+'count'))
				print '# NOEs to %s %d' %(lme, temp[labeling + '_NOE'].sum())
				print 'Average NOEs per %s %.2f' %(lme, np.round(temp[labeling + '_NOE'].sum()/float(temp.shape[0]),2))
				# if temp.shape[0] != 0: print '%.2f NOE per %s' %(np.round(temp[labeling + '_NOE'].mean(),2), lme)
			
			if lowCut == 6.0 and labeling == 'ILVMAT':
				subnetworks = [[]]
				used = []
				i = 0
				LN_list = PDB_Summary.dropna(axis=0, subset=[labeling + '_LN']).index.tolist()
				for methyl in LN_list:
					if methyl not in used:
						i+=1
						subnetworks.append(PDB_Summary.loc[methyl, labeling + '_Donors'].split())
					if methyl in used: 
						i = i
					for methyl2 in LN_list: 
						if methyl2 != methyl:
							if methyl2 in subnetworks[i]:
								donors = PDB_Summary.loc[methyl2, labeling + '_Donors'].split()
								for donor in donors:
									subnetworks[i].append(donor)
									used.append(donor)
									used.append(methyl)
									used.append(methyl2)
									PDB_Summary.loc[methyl2,labeling + '_Subnet_ID'] = i
			print ''

		##-------------------------------------------------------------------------
		#Plot Global Network 
		##-------------------------------------------------------------------------

			fig1=plt.figure(figsize=(5.3,5))
			ax = fig1.add_subplot(111)
			plotmatrix = Mmatrix.reindex(plotlist, columns=plotlist)
			xticks= np.arange(plotmatrix.shape[0])
			cmap = plt.get_cmap('viridis')
			cmap.set_under(color='white')
			ax = sb.heatmap(plotmatrix.fillna(0.0), cmap=cmap, vmin = 3.5, vmax= 7.0,square=True, xticklabels=xticks,yticklabels=xticks,cbar_kws=dict(shrink = 0.5))

			if plotmatrix.shape[0] > 100: inc = 20
			if plotmatrix.shape[0] < 100: inc = 10 
			ax.set_title(r"%s %s$\AA$ Cut Off" %(labeling,str(lowCut)))
			ax.set_xticks(np.arange(0,plotmatrix.shape[0],inc))
			ax.set_xticklabels(np.arange(0,plotmatrix.shape[0],inc))
			ax.set_yticks(np.arange(0,plotmatrix.shape[0],inc))
			ax.set_yticklabels(np.arange(0,plotmatrix.shape[0],inc))
			ax.set_ylabel('Methyl Number')
			ax.set_xlabel('Methyl Number')
			for me in labeling:
				ax.axhline(y=plotgrid[me],color=[0.6,0.6,0.6],alpha=0.5)
				ax.axvline(x=plotgrid[me],color=[0.6,0.6,0.6],alpha=0.5)
			ax.invert_xaxis()
			ax.spines['right'].set_visible(True)
			ax.spines['top'].set_visible(True)
			ax.spines['bottom'].set_visible(True)
			ax.spines['left'].set_visible(True)
			plt.tight_layout(pad = 0.4, w_pad = 0.4, h_pad = 0.4)
			plt.close()
			pdf1.savefig(fig1, transparent=True)


			###-------------------------------------------------------------------------
			# Plot Subnetworks Network 
			###-------------------------------------------------------------------------
			if lowCut == 6.0 and labeling == 'ILVMAT':
				for subnet in 	PDB_Summary[labeling + '_Subnet_ID'].unique().tolist():
					subnetwork = PDB_Summary[PDB_Summary[labeling + '_Subnet_ID'] == subnet].index.tolist()
					print subnetwork
					if len(subnetwork) > 5:
						fig2=plt.figure(figsize=(3.3,3))
						ax = fig2.add_subplot(111)
						plotmatrix = Mmatrix.reindex(subnetwork, columns=subnetwork).copy(deep=True)
						plotmatrix2 = plotmatrix.reindex(plotlist,columns=plotlist).copy(deep=True)
						xticks= np.arange(plotmatrix2.shape[0])
						cmap = plt.get_cmap('viridis')
						cmap.set_under(color='white')
						ax = sb.heatmap(plotmatrix2.fillna(0.0), cmap=cmap, vmin = 3.5, vmax= 6.5,square=True, xticklabels=xticks,yticklabels=xticks,cbar_kws=dict(shrink = 0.5))
						ax.set_title(r"%s %s$\AA$ Cut Off" %(labeling,str(lowCut)))
						if plotmatrix2.shape[0] > 100: inc = 20
						if plotmatrix2.shape[0] < 100: inc = 10 
						ax.set_title(r"subnet %s %s %s$\AA$ Cut Off" %(str(subnet),labeling,str(lowCut)))
						ax.set_xticks(np.arange(0,plotmatrix2.shape[0],inc))
						ax.set_xticklabels(np.arange(0,plotmatrix2.shape[0],inc))
						ax.set_yticks(np.arange(0,plotmatrix2.shape[0],inc))
						ax.set_yticklabels(np.arange(0,plotmatrix2.shape[0],inc))
						ax.set_ylabel('Methyl Number')
						ax.set_xlabel('Methyl Number')
						for me in labeling:
							ax.axhline(y=plotgrid[me],color=[0.6,0.6,0.6],alpha=0.5)
							ax.axvline(x=plotgrid[me],color=[0.6,0.6,0.6],alpha=0.5)
						ax.invert_xaxis()
						ax.spines['right'].set_visible(True)
						ax.spines['top'].set_visible(True)
						ax.spines['bottom'].set_visible(True)
						ax.spines['left'].set_visible(True)
						# fig.colorbar(im, ax=ax, shrink = 0.5)
						plt.tight_layout(pad = 0.4, w_pad = 0.4, h_pad = 0.4)
						plt.close()
						pdf2.savefig(fig2, transparent=True)

			####-------------------------------------------------------------------------
			# Plot Local Network with all geminal methys shown
			####-------------------------------------------------------------------------

			if lowCut == 6.0 and labeling == 'ILVMAT':
				for methyl in Mmatrix.index.tolist():
					donors = Mmatrix.dropna(axis=0,subset=[methyl], how = 'any').index.tolist()
					if len(donors) >= 4:
						fig3=plt.figure(figsize=(2.2,2))
						ax = fig3.add_subplot(111)
						plotmatrix2 = Mmatrix.reindex(donors, columns=donors).copy(deep=True)
						for row in donors:
							if row != methyl:
								for col in donors:
									if col != methyl:
										plotmatrix2.loc[row,col] = 0.0
						cmap = plt.get_cmap('viridis')
						cmap.set_under(color='none')
						ax = sb.heatmap(plotmatrix2.fillna(0.0), cmap=cmap, vmin = 3.5, vmax= 6.5,square=True,cbar_kws=dict(shrink = 0.5))
						ax.set_title(r"%s %s" %(methyl, PDB_Summary.loc[methyl, labeling+'_LN']))
						# ax.set_ylabel('Methyl Number')
						# ax.set_xlabel('Methyl Number')
						ax.spines['right'].set_visible(True)
						ax.spines['top'].set_visible(True)
						ax.spines['bottom'].set_visible(True)
						ax.spines['left'].set_visible(True)
						plt.tight_layout(pad = 0.4, w_pad = 0.4, h_pad = 0.4)
						plt.close()
						pdf3.savefig(fig3, transparent=True)
				pdf3.close()
		PDB_Summary.sort_values( by=['type','Resid']).to_csv(csvoutname + '_' +method + "_"+ str(lowCut) + "_PDB_summary.csv", columns=PDB_Summary.columns.tolist()[2:])
	pdf1.close()
	pdf2.close()
	out_table.to_csv(outname + '_' + method + '.csv')


#####-------------------------------------------------------------------------
## Plot Summaries 
#####-------------------------------------------------------------------------
colors = {'sym':'#ffa500','mono':'#b0b91f', 'stero':'#8d4c7d'}
pdf =  PdfPages(outname+'_Network_Comp_Summary.pdf')
for lowCut in lowCuts:
	fig=plt.figure(figsize=(6,1.55*3),constrained_layout=True)
	gspec = gridspec.GridSpec(ncols=5, nrows = 3, figure=fig, width_ratios=[1.0, float(5/6.0), float(4/6.0),float(4/6.0),float(3/6.0)], height_ratios=[1,1,1])
	col=-1
	xvals = [0,1,2,3,4,5]
	Summary_limits = []
	for method in LV_Labeling:
		out_table = eval(method + "_summary")
		out_table.fillna(0.0)
		for methyls in Labelings:
			for me in methyls:
				value = float(out_table.loc[methyls + '_' + me ,str(lowCut)+'A_NOE/me'])
				Summary_limits.append(value)
	for methyls in Labelings:
		col+=1
		row=-1
		for method in LV_Labeling:
			out_table = eval(method + "_summary")
			row+=1
			xval = []
			xlabels = []
			ay1, ay2, ay3 = [],[],[]
			width = 0.45
			for i in range(len(methyls)):
				me = methyls[i]
				xlabels.append(me)
				xval.append(xvals[i])
				if methyls + '_' + me  in out_table.index.tolist():
					ay1.append(float(out_table.loc[methyls + '_' + me ,str(lowCut)+'A_NOE/me']))
					ay2.append(float(out_table.loc[methyls + '_' + me ,str(lowCut)+'A_LN/me']))
					ay3.append(float(out_table.loc[methyls + '_' + me ,str(lowCut)+'A_ULN/me']))
			xval = np.array(xval)
			ax = fig.add_subplot(gspec[row,col])
			ax.bar(xval, np.array(ay1), width, color=[0.6,0.6,0.6], edgecolor='none', label= 'NOE')
			ax.bar(xval + width, np.array(ay2), width, color=[0.25,0.8,0.92], edgecolor='none', label= 'LN')
			ax.bar(xval + width, np.array(ay3), width, color=colors[method], edgecolor='none', label= 'ULN')
			ax.set_ylim([0, np.round(max(Summary_limits),0)+0.5])
			ax.set_xticks(xval+width*0.5)
			ax.yaxis.set_major_formatter(FormatStrFormatter('%2.0f'))
			ax.set_xticklabels(xlabels)
			if col ==0 and row ==0:
				ax.set_ylabel('Avg/Methyl')
				ax.annotate('LV-13CH3/13CH3', (0.05, 0.95), xycoords='axes fraction')
			if col ==0 and row ==1:
				ax.set_ylabel('Avg/Methyl')
				ax.annotate('LV-13CH3/12CD3', (0.05, 0.95), xycoords='axes fraction')
			if col ==0 and row ==2:
				ax.set_ylabel('Avg/Methyl')
				ax.annotate(r'LV-$\delta$1$\gamma$1-13CH3', (0.05, 0.95), xycoords='axes fraction')
			if col ==1:
				ax.annotate('NOE', (0.05, 0.95), xycoords='axes fraction',color=[0.6,0.6,0.6])
				ax.annotate('LN', (0.05, 0.85), xycoords='axes fraction',color=[0.25,0.8,0.92])
				ax.annotate('ULN', (0.05, 0.75), xycoords='axes fraction',color=colors[method])
			if  col == 2 and row ==0 :ax.set_title("%sA Cut Off" %(str(lowCut)))
			plt.close()
	pdf.savefig(fig, transparent=True)
pdf.close()


pdf = PdfPages(outname+'_Assign_Networks_Summarys.pdf')
for lowCut in lowCuts:
	fig1=plt.figure(figsize=(6.0,1.92),constrained_layout=True)
	gspec1 = gridspec.GridSpec(ncols=4, nrows = 1, figure=fig1, width_ratios=[1.0,float(8/6.0),1.0, float(12/6.0)], height_ratios=[1])
	fig=plt.figure(figsize=(6.5,1.55*3),constrained_layout=True)
	gspec = gridspec.GridSpec(ncols=5, nrows = 3, figure=fig, width_ratios=[1.0, float(5/6.0), float(4/6.0),float(4/6.0),float(3/6.0)], height_ratios=[1,1,1])
	ax1 =fig1.add_subplot(gspec1[0,0])
	ax1.bar(np.array([0,1,2,3,4,5]), np.array(pmethyls),0.6, color=[0.6,0.6,0.6], edgecolor='none')
	ax1.set_ylim([0,max(pmethyls)+5])
	ax1.set_xticks(np.array([0,1,2,3,4,5]))
	ax1.set_xticklabels(['I','L','V','M','A','T'])
	ax1.set_ylabel('% Methyls')
	ax1.yaxis.set_major_formatter(FormatStrFormatter('%3.0f'))
	ax2 =fig1.add_subplot(gspec1[0,1])
	ax2.bar(np.array([0,1,2,3,4,5,6]), np.array(pprotons),0.5, color=[0.6,0.6,0.6], edgecolor='none')
	ax2.bar(np.array([0,1,2,3,4,5,6]), np.array(pprotonsmono),0.5, color=[0.4,0.4,0.4], edgecolor='none', )
	ax2.set_ylim([0,30])
	ax2.set_xticks(np.array([0,1,2,3,4,5,6]))
	ax2.set_xticklabels(['Ex','I','L','V','M','A','T'])
	ax2.set_ylabel('% Protons')
	ax2.set_title(str(lowCut)+'A Cutoff')
	ax2.yaxis.set_major_formatter(FormatStrFormatter('%3.0f'))
	ax2.annotate('LV-13CH3/13CH3', (0.05, 0.95), color=[0.6,0.6,0.6], xycoords='axes fraction')
	ax2.annotate('LV-13CH3/12CD3', (0.05, 0.83), color=[0.4,0.4,0.4], xycoords='axes fraction')
	width = 0.3
	ax3 = fig1.add_subplot(gspec1[0,3])
	t1 = np.array([100.0,100.0,100.0,100.0,100.0])
	sym2, sym3 ,mono2, mono3, stero2, stero3= [],[],[],[],[],[]
	sym_table = eval("sym_summary")
	mono_table = eval("mono_summary")
	stero_table = eval("stero_summary")
	for methyls in Labelings:
		sym2.append(float(sym_table.loc[methyls + '_Total' ,str(lowCut)+'A_All']))
		sym3.append(float(sym_table.loc[methyls + '_Total' ,str(lowCut)+'A_Unambiguous']))
		mono2.append(float(mono_table.loc[methyls + '_Total' ,str(lowCut)+'A_All']))
		mono3.append(float(mono_table.loc[methyls + '_Total' ,str(lowCut)+'A_Unambiguous']))
		stero2.append(float(stero_table.loc[methyls + '_Total' ,str(lowCut)+'A_All']))
		stero3.append(float(stero_table.loc[methyls + '_Total' ,str(lowCut)+'A_Unambiguous']))
	ax3.bar(np.array([0,1,2,3,4]), np.array(t1), width, color=[0.6,0.6,0.6], edgecolor='none', label= 'Iso sym')
	ax3.bar(np.array([0,1,2,3,4]), np.array(sym2), width, color=[0.25,0.8,0.92], edgecolor='none', label= 'LN sym')
	ax3.bar(np.array([0,1,2,3,4]), np.array(sym3), width, color='#ffa500', edgecolor='none', label= 'ULN sym')
	ax3.bar(np.array([0,1,2,3,4]) + width, np.array(t1), width, color=[0.6,0.6,0.6], edgecolor='none', label= 'Iso mono')
	ax3.bar(np.array([0,1,2,3,4]) + width, np.array(mono2), width, color=[0.25,0.8,0.92], edgecolor='none', label= 'LN mono')
	ax3.bar(np.array([0,1,2,3,4]) + width, np.array(mono3), width, color='#b0b91f', edgecolor='none', label= 'ULN mono')
	ax3.bar(np.array([0,1,2,3,4]) + 2* width, np.array(t1), width, color=[0.6,0.6,0.6], edgecolor='none', label= 'Iso mono')
	ax3.bar(np.array([0,1,2,3,4]) + 2* width, np.array(stero2), width, color=[0.25,0.8,0.92], edgecolor='none', label= 'LN mono')
	ax3.bar(np.array([0,1,2,3,4]) + 2* width, np.array(stero3), width, color='#8d4c7d', edgecolor='none', label= 'ULN mono')
	ax3.set_ylim([0, 110])
	ax3.set_xticks(np.array([0,1,2,3,4])+width)
	ax3.yaxis.set_major_formatter(FormatStrFormatter('%3.0f'))
	ax3.set_xticklabels(Labelings, rotation=90)
	ax3.set_yticks([0,25,50,75,100])
	ax3.set_ylabel('%Methyls')
	isodist = []
	for me in 'ILVMAT':
		if float(sym_table.loc['ILVMAT_Total', str(lowCut)+'A_iso']) >  0:
			isodist.append((float(sym_table.loc['ILVMAT_'+me, str(lowCut)+'A_iso'])/float(sym_table.loc['ILVMAT_Total', str(lowCut)+'A_iso']))*100)
		if float(sym_table.loc['ILVMAT_Total', str(lowCut)+'A_iso']) == 0:
			isodist.append(0.0)
	ax4 =fig1.add_subplot(gspec1[0,2])
	ax4.bar(np.array([0,1,2,3,4,5]), np.array(isodist),0.5, color=[0.6,0.6,0.6], edgecolor='none')
	ax4.set_ylim([0,max(isodist) + 10])
	ax4.set_xticks(np.array([0,1,2,3,4,5]))
	ax4.set_xticklabels(['I','L','V','M','A','T'])
	ax4.set_ylabel('%Isolated Methyls')
	ax4.yaxis.set_major_formatter(FormatStrFormatter('%3.0f'))
	col=-1
	xvals = [0,1,2,3,4,5]
	for methyls in Labelings:
		col+=1
		row=-1
		for method in LV_Labeling:
			out_table = eval(method + "_summary")
			row+=1
			xval = []
			xlabels = []
			ay1, ay2, ay3 = [],[],[]
			width = 0.3
			for i in range(len(methyls)):
				me = methyls[i]
				xlabels.append(me)
				xval.append(xvals[i])
				if methyls + '_' + me  in out_table.index.tolist():
					ay1.append(float(out_table.loc[methyls + '_' + me ,str(lowCut)+'A_isof']))
					ay2.append(float(out_table.loc[methyls + '_' + me ,str(lowCut)+'A_Ambiguous']))
					ay3.append(float(out_table.loc[methyls + '_' + me ,str(lowCut)+'A_Unambiguous']))
			xval = np.array(xval)
			ax = fig.add_subplot(gspec[row,col])
			ax.bar(xval, np.array(ay1), width, color=[0.6,0.6,0.6], edgecolor='none', label= 'Isolated')
			ax.bar(xval + width, np.array(ay2), width, color=[0.25,0.8,0.92], edgecolor='none', label= 'Ambiguous')
			ax.bar(xval + 2*width, np.array(ay3), width, color=colors[method], edgecolor='none', label= 'Unambiguous')
			ax.set_ylim([0, 110])
			ax.set_xticks(xval+width)
			ax.yaxis.set_major_formatter(FormatStrFormatter('%3.0f'))
			ax.set_xticklabels(xlabels)
			ax.set_yticks([0,25,50,75,100])
			if col ==0 and row ==0:
				ax.set_ylabel('%Methyls')
				ax.annotate('LV-13CH3/13CH3', (0.05, 0.95), xycoords='axes fraction')
			if col ==0 and row ==1:
				ax.set_ylabel('%Methyls')
				ax.annotate('LV-13CH3/12CD3', (0.05, 0.95), xycoords='axes fraction')
			if col ==0 and row ==2:
				ax.set_ylabel('%Methyls')
				ax.annotate(r'LV-$\delta$1$\gamma$1-13CH3', (0.05, 0.95), xycoords='axes fraction')
			if col ==1:
				ax.annotate('iso', (0.05, 0.95), xycoords='axes fraction',color=[0.6,0.6,0.6])
				ax.annotate('ALN', (0.05, 0.85), xycoords='axes fraction',color=[0.25,0.8,0.92])
				ax.annotate('ULN', (0.05, 0.75), xycoords='axes fraction',color=colors[method])
			if  col == 2 and row ==0 :ax.set_title("%sA Cut Off" %(str(lowCut)))
			plt.close()
	pdf.savefig(fig1, transparent=True)
	pdf.savefig(fig, transparent=True)
pdf.close()
			

end_time = datetime.now()
runtime = end_time - start_time
print'Duration: ' + str(runtime)